
-- ============================================================
-- V1__Init_Schema.sql
-- Baseline migration for Spring Boot 4.0.1 application
-- Database: PostgreSQL
-- ============================================================

-- ============================================================
-- 1. SEQUENCES
-- ============================================================
-- Functional ID sequence (used by FunctionalIdGenerator for business-readable IDs)
CREATE SEQUENCE IF NOT EXISTS greeting_sequence START WITH 1 INCREMENT BY 1;

-- Hibernate Envers revision sequence (pooled allocation size = 50)
CREATE SEQUENCE IF NOT EXISTS revinfo_seq START WITH 1 INCREMENT BY 50;

-- ============================================================
-- 2. CORE TABLES
-- ============================================================

-- User table (Spring Security)
CREATE TABLE app_user (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(255) UNIQUE,
    password VARCHAR(255)
);

-- Greeting entity (extends AbstractBaseEntity, uses TSID for id)
CREATE TABLE greeting (
    id BIGINT NOT NULL PRIMARY KEY,
    version INTEGER,
    created_at TIMESTAMP(6) WITH TIME ZONE NOT NULL,
    updated_at TIMESTAMP(6) WITH TIME ZONE,
    created_by_id VARCHAR(255) NOT NULL,
    updated_by_id VARCHAR(255),
    reference VARCHAR(32) NOT NULL UNIQUE,
    recipient VARCHAR(255) NOT NULL,
    message VARCHAR(255) NOT NULL
);

-- ============================================================
-- 3. HIBERNATE ENVERS AUDIT TABLES (ValidityAuditStrategy)
-- ============================================================
-- Configuration:
--   audit_table_suffix=_AUD (PostgreSQL folds to lowercase: _aud)
--   revision_field_name=REV (folds to: rev)
--   revision_type_field_name=REVTYPE (folds to: revtype)
--   ValidityAuditStrategy adds REVEND column

-- Revision info table (custom entity with username)
CREATE TABLE revinfo (
    rev INTEGER NOT NULL PRIMARY KEY,
    revtstmp BIGINT,
    username VARCHAR(255)
);

-- Greeting audit history table
CREATE TABLE greeting_aud (
    id BIGINT NOT NULL,
    rev INTEGER NOT NULL,
    revtype SMALLINT,
    revend INTEGER,
    reference VARCHAR(32),
    recipient VARCHAR(255),
    message VARCHAR(255),
    PRIMARY KEY (rev, id),
    CONSTRAINT fk_greeting_aud_rev FOREIGN KEY (rev) REFERENCES revinfo (rev),
    CONSTRAINT fk_greeting_aud_revend FOREIGN KEY (revend) REFERENCES revinfo (rev)
);

-- ============================================================
-- 4. BUSINESS ACTIVITY LOG
-- ============================================================
CREATE TABLE business_activity_log (
    id BIGINT NOT NULL PRIMARY KEY,
    occurred_at TIMESTAMP(6) WITH TIME ZONE NOT NULL,
    actor_user_id VARCHAR(255),
    event_type VARCHAR(255) NOT NULL,
    aggregate_type VARCHAR(255),
    aggregate_id VARCHAR(255),
    trace_id VARCHAR(255),
    data JSONB
);

-- Indexes for query performance
CREATE INDEX idx_business_activity_log_trace_id ON business_activity_log (trace_id);
CREATE INDEX idx_business_activity_log_aggregate ON business_activity_log (aggregate_type, aggregate_id);
CREATE INDEX idx_business_activity_log_event_type ON business_activity_log (event_type);
CREATE INDEX idx_business_activity_log_occurred_at ON business_activity_log (occurred_at);

-- ============================================================
-- 5. SPRING MODULITH EVENT PUBLICATION (Transactional Outbox)
-- ============================================================
-- Schema from Spring Modulith documentation for PostgreSQL
-- https://docs.spring.io/spring-modulith/reference/appendix.html
CREATE TABLE IF NOT EXISTS event_publication (
    id                     UUID NOT NULL PRIMARY KEY,
    listener_id            TEXT NOT NULL,
    event_type             TEXT NOT NULL,
    serialized_event       TEXT NOT NULL,
    publication_date       TIMESTAMP WITH TIME ZONE NOT NULL,
    completion_date        TIMESTAMP WITH TIME ZONE,
    status                 TEXT,
    completion_attempts    INT,
    last_resubmission_date TIMESTAMP WITH TIME ZONE
);

CREATE INDEX IF NOT EXISTS event_publication_serialized_event_hash_idx
    ON event_publication USING hash(serialized_event);
CREATE INDEX IF NOT EXISTS event_publication_by_completion_date_idx
    ON event_publication (completion_date);

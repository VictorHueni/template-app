package com.example.demo.greeting.service;

import java.util.List;
import java.util.Optional;

import org.springframework.context.ApplicationEventPublisher;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.history.Revision;
import org.springframework.data.history.Revisions;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.example.demo.common.audit.CustomRevisionEntity;
import com.example.demo.common.repository.FunctionalIdGenerator;
import com.example.demo.greeting.dto.GreetingRevisionDTO;
import com.example.demo.greeting.event.GreetingCreatedEvent;
import com.example.demo.greeting.model.Greeting;
import com.example.demo.greeting.repository.GreetingRepository;

@Service
public class GreetingService {

    private final FunctionalIdGenerator idGenerator;
    private final GreetingRepository repository;
    private final ApplicationEventPublisher eventPublisher;

    public GreetingService(
            FunctionalIdGenerator idGenerator,
            GreetingRepository repository,
            ApplicationEventPublisher eventPublisher) {
        this.idGenerator = idGenerator;
        this.repository = repository;
        this.eventPublisher = eventPublisher;
    }

    @Transactional
    public Greeting createGreeting(String message, String recipient) {
        // Create entity - TSID (id) is auto-generated by Hibernate via @Tsid annotation
        Greeting entity = new Greeting(recipient, message);

        // Generate human-readable functional ID (e.g., GRE-2025-000042)
        // This runs in its own transaction to ensure sequence integrity
        String reference = idGenerator.generate("greeting_sequence", "GRE");
        entity.setReference(reference);

        // Save: Both TSID and functional ID are now set
        Greeting saved = repository.save(entity);

        // Publish domain event (transactionally with the save)
        eventPublisher.publishEvent(new GreetingCreatedEvent(
                saved.getId(),
                saved.getReference(),
                saved.getRecipient(),
                saved.getMessage(),
                saved.getCreatedBy(),
                saved.getCreatedAt()
        ));

        return saved;
    }

    public Page<Greeting> getGreetings(int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt"));
        return repository.findAll(pageable);
    }

    public Optional<Greeting> getGreeting(Long id) {
        return repository.findById(id);
    }

    public Optional<Greeting> updateGreeting(Long id, String message, String recipient) {
        return repository.findById(id)
                .map(existing -> {
                    existing.setMessage(message);
                    existing.setRecipient(recipient);
                    return repository.save(existing);
                });
    }

    public Optional<Greeting> patchGreeting(Long id, String message, String recipient) {
        return repository.findById(id)
                .map(existing -> {
                    if (message != null) {
                        existing.setMessage(message);
                    }
                    if (recipient != null) {
                        existing.setRecipient(recipient);
                    }
                    return repository.save(existing);
                });
    }

    public boolean deleteGreeting(Long id) {
        if (repository.existsById(id)) {
            repository.deleteById(id);
            return true;
        }
        return false;
    }

    // ============================================================
    // Audit History Methods (Internal/Admin Use)
    // ============================================================

    /**
     * Get all revisions for a greeting (full audit trail).
     *
     * @param id the greeting ID
     * @return list of all revisions, oldest first
     */
    public List<GreetingRevisionDTO> getGreetingHistory(Long id) {
        Revisions<Integer, Greeting> revisions = repository.findRevisions(id);
        return revisions.stream()
                .map(this::toRevisionDTO)
                .toList();
    }

    /**
     * Get a specific revision of a greeting (point-in-time query).
     *
     * @param id the greeting ID
     * @param revisionNumber the revision number to retrieve
     * @return the greeting state at that revision, or empty if not found
     */
    public Optional<GreetingRevisionDTO> getGreetingAtRevision(Long id, Integer revisionNumber) {
        return repository.findRevision(id, revisionNumber)
                .map(this::toRevisionDTO);
    }

    /**
     * Get the most recent revision of a greeting (last change info).
     *
     * @param id the greeting ID
     * @return the latest revision, or empty if entity has no revisions
     */
    public Optional<GreetingRevisionDTO> getLastGreetingRevision(Long id) {
        return repository.findLastChangeRevision(id)
                .map(this::toRevisionDTO);
    }

    /**
     * Convert a Spring Data Revision to our DTO.
     */
    private GreetingRevisionDTO toRevisionDTO(Revision<Integer, Greeting> revision) {
        Greeting entity = revision.getEntity();
        var metadata = revision.getMetadata();

        // Extract username from custom revision entity
        String modifiedBy = metadata.getDelegate() instanceof CustomRevisionEntity cre
                ? cre.getUsername()
                : "unknown";

        return new GreetingRevisionDTO(
                metadata.getRequiredRevisionNumber(),
                metadata.getRequiredRevisionInstant(),
                metadata.getRevisionType().name(),
                modifiedBy,
                entity.getId(),
                entity.getReference(),
                entity.getRecipient(),
                entity.getMessage()
        );
    }
}
